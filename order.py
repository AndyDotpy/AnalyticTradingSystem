from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce
from uuid import uuid4
from collections import deque


class OrderRecord:
    """
    A wrapper around MarketOrderRequest to give each a unique id generated by uuid4()
    Raises ValueError is symbol is None or quantity is None or quantity is negative
    """
    def __init__(
        self,
        symbol: str = None,
        qty: int = None,
        side: str = OrderSide.BUY,
        time_in_force: str = TimeInForce.DAY
    ):

        # Assuming this is during automation this should stop the code as it will only happen if something really goes wrong
        if symbol is None:
            raise ValueError("The symbol when creating an OrderRecord must not be None, give a proper symbol value!")
        elif qty is None:
            raise ValueError("The qty when creating an OrderRecord must not be None, give a proper quantity!")
        elif qty <= 0:
            raise ValueError("The qty when creating an OrderRecord is <= 0!")

        self.id: int = int(uuid4())
        self.failed: bool = False  # Not really needed because we can check if self.exception is False, will remove later
        self.exception: Exception | None = None

        self.market_order = MarketOrderRequest(
            symbol=symbol,
            qty=qty,
            side=side,
            time_in_force=time_in_force
        )

    def __str__(self):
        return (
            f"Symbol:     {self.market_order.symbol}\n"
            f"Quantity:   {self.market_order.qty}\n"
            f"Action:     {self.market_order.side}\n"
            f"Trade Time: {self.market_order.time_in_force}\n"
            f"Failed:     {self.failed}\n"
            f"Unique ID:  {self.id}\n"
        )


class OrderUtility:
    all_orders: dict[str, dict[int, "OrderRecord"]] = {}
    failed_orders: dict[str, deque["OrderRecord"]] = {}  # str key is queue name, then a deque of OrderRecords that failed

    @staticmethod
    def create_order(symbol: str, qty: int, side: str | None = None, overwrite: bool = False) -> str:
        """
        Creates an OrderRecord based of given parameters, if order exists and overwrite is set to True it will be
        overwritten, qty is the quantity of shares for a stock, side is buy or sell a stock
        :param str as symbol:
        :param int as qty:
        :param str or None as side:
        :param bool as overwrite:
        :return str as id: 
        """
        if side == "buy":
            side = OrderSide.BUY
        else:
            side = OrderSide.SELL

        new_order = OrderRecord(symbol, qty, side)
        name = new_order.id
        if symbol in OrderUtility.all_orders:
            if name in OrderUtility.all_orders[symbol]:
                if overwrite:
                    print(f"Order stored, overwritten the previous {name} at {symbol}")
                    OrderUtility.all_orders[symbol][name] = new_order
                else:
                    print("Order storing cancelled")
            else:
                OrderUtility.all_orders[symbol][name] = new_order
        else:
            OrderUtility.all_orders[symbol] = {name: new_order}
        
        return name

    @staticmethod
    def display_orders() -> None:
        """
        Displays all orders and there ID
        :return:
        """
        for symbol, orders in OrderUtility.all_orders.items():
            print(f"Stock Symbol: {symbol}")
            for name, order in orders.items():
                print(f"\tOrder ID: {name}\n\t\t{order.market_order}")

    @staticmethod
    def remove_order(symbol: str, unique_id: int) -> None:
        """
        Removed an order based off its symbol and unique id
        :param str as symbol:
        :param int as unique_id:
        :return:
        """
        OrderUtility.all_orders[symbol].pop(unique_id)
        print("Removed the order!")
        if len(OrderUtility.all_orders[symbol]) == 0:
            OrderUtility.all_orders.pop(symbol)
            print(f"Removed {symbol} from all_orders as no orders with that symbol remained")

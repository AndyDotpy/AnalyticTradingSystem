from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce
from utilities import try_int, yes_or_no
import utilities as u
from uuid import uuid4


class OrderRecord:
    """
    A wrapper around MarketOrderRequest to give each a unique id generated by uuid4()
    """

    def __init__(
        self,
        symbol: str = None,
        qty: int = None,
        side: str = OrderSide.BUY,
        time_in_force: str = TimeInForce.DAY
    ):

        # Assuming this is during automation this should stop the code as it will only happen if something really goes wrong
        if symbol is None:
            raise ValueError("The symbol when creating an OrderRecord must not be None, give a proper symbol value!")
        elif qty is None:
            raise ValueError("The qty when creating an OrderRecord must not be None, give a proper quantity!")
        elif qty <= 0:
            raise ValueError("The qty when creating an OrderRecord is <= 0!")

        self.id: int = int(uuid4())
        self.failed: bool = False
        self.exception: Exception | None = None

        self.market_order = MarketOrderRequest(
            symbol=symbol,
            qty=qty,
            side=side,
            time_in_force=time_in_force
        )

    def __str__(self):
        return (
            f"Symbol:     {self.market_order.symbol}\n"
            f"Quantity:   {self.market_order.qty}\n"
            f"Action:     {self.market_order.side}\n"
            f"Trade Time: {self.market_order.time_in_force}\n"
            f"Failed:     {self.failed}\n"
            f"Unique ID:  {self.id}\n"
        )


class OrderUtility:
    @staticmethod
    def create_order() -> None:
        """
        TODO: Needs default parameters that cause it to skip the user requests for automation
        Creates an order expecting the user input
        :return:
        """
        symbol = input("Enter the symbol of the stock: ")

        qty: int | None = None
        while qty is None:
            qty = try_int(input("Enter quantity: "))

        side: str | None = None
        while side != "buy" and side != "sell":
            side = input("Enter \"buy\" or \"sell\": ").lower()
        if side == "buy":
            side = OrderSide.BUY
        else:
            side = OrderSide.SELL

        #id is an int need to take that into consideration....
        new_order = OrderRecord(symbol, qty, side)
        name = new_order.id
        if symbol in u.all_orders:
            if name in u.all_orders[symbol]:
                confirm = input("A order with this name already exists, do you want to overwrite? \"y\" or \"n\"").lower()
                if confirm == "y":
                    print(f"Order stored, overwritten the previous {name} at {symbol}")
                    u.all_orders[symbol][name] = new_order
                else:
                    print("Order storing cancelled")
            else:
                u.all_orders[symbol][name] = new_order
        else:
            u.all_orders[symbol] = {name: new_order}

    @staticmethod
    def display_orders() -> None:
        """
        Displays all orders and there ID
        :return:
        """
        for symbol, orders in u.all_orders.items():
            print(f"Stock Symbol: {symbol}")
            for name, order in orders.items():
                print(f"\tOrder ID: {name}\n\t\t{order.market_order}")

    @staticmethod
    def remove_order() -> None:
        """
        Removed an order based off its symbol and unique id
        :return:
        """
        if len(u.all_orders) == 0:
            print("There are no orders to be removed...")
            return

        if yes_or_no(msg="View orders") == "y":
            OrderUtility.display_orders()

        symbol: str = input("Enter symbol: ")
        unique_id: int | None = None

        while unique_id is None:
            unique_id = try_int(input("Enter unique id: "))

        if symbol not in u.all_orders:
            print("This symbol is not in all_orders")
            return

        if unique_id not in u.all_orders[symbol]:
            print(f"Unique ID does not exist for the symbol {symbol}")
            return

        u.all_orders[symbol].pop(unique_id)
        print("Removed the order!")
        if len(u.all_orders[symbol]) == 0:
            u.all_orders.pop(symbol)
            print(f"Removed {symbol} from all_orders as no orders with that symbol remained")

